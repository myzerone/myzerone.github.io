<!DOCTYPE html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]--><!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8"><![endif]--><!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9"><![endif]--><!--[if gt IE 8]><!--><html class="no-js">
<!--<![endif]--> <head> <meta charset="UTF-8"> <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"> <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"> <title>面向切面编程（AOP） – myzerone</title> <meta name="description" content="记录下自己学习的过程、点滴，也为了分享自己的收获。"> <meta name="keywords" content="iOS, AOP"> <!-- Twitter Cards --> <meta name="twitter:card" content="summary"> <meta name="twitter:image" content="/assets/img/logo.png"> <meta name="twitter:title" content="面向切面编程（AOP）"> <meta name="twitter:description" content="主要介绍Objective-C实现AOP的三种方式：Method Swizzling、Aspects、NSProxy"> <!-- Open Graph --> <meta property="og:locale" content="zh_CN"> <meta property="og:type" content="article"> <meta property="og:title" content="面向切面编程（AOP）"> <meta property="og:description" content="主要介绍Objective-C实现AOP的三种方式：Method Swizzling、Aspects、NSProxy"> <meta property="og:url" content="/posts/2015/10/26/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B(AOP)/"> <meta property="og:site_name" content="myzerone"> <meta property="og:image" content="/assets/img/logo.png"> <!-- Webmaster Tools verfication --> <meta name="google-site-verification" content="Oq-I-tGK8y1zoHLnZQnfe7rH6rkjqyjqZfBtvADe2uU"> <link rel="canonical" href="/posts/2015/10/26/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B(AOP)/"> <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="myzerone Feed"> <!-- Handheld --> <meta name="HandheldFriendly" content="True"> <meta name="MobileOptimized" content="320"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- CSS --> <link rel="stylesheet" href="/assets/css/main.css"> <!-- JS --> <script src="/assets/js/modernizr-3.3.1.custom.min.js"></script> <!-- Favicons --> <link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"> <link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"> <link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"> <link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"> <link rel="shortcut icon" type="image/png" href="/favicon.png"> <link rel="shortcut icon" href="/favicon.ico"> <!-- Background Image --> <style type="text/css">body {background-image:url(/assets/img/placeholder-big.jpg); background-repeat: no-repeat; background-size: cover; }</style> <!-- Post Feature Image --> </head> <body> <nav id="dl-menu" class="dl-menuwrapper" role="navigation"> <button class="dl-trigger">Open Menu</button> <ul class="dl-menu"> <!-- 首页 --> <li> <a href="/">首页</a> </li> <!-- 关于 --> <li> <a href="#">关于</a> <ul class="dl-submenu"> <li> <img src="/assets/img/logo.png" alt="myzerone photo" class="author-photo"> <h4>myzerone</h4> <p>记录下自己学习的过程、点滴，也为了分享自己的收获。</p> </li> <li><a href="/about/"><span class="btn btn-inverse">Learn More</span></a></li> <li> <a href="mailto:myzerone@myzerone.com" target="_blank" rel="noopener noreferrer"><i class="fa fa-fw fa-envelope-square"></i> Email</a> </li> <li> <a href="http://github.com/myzerone" target="_blank" rel="noopener noreferrer"><i class="fa fa-fw fa-github"></i> Github</a> </li> </ul>
<!-- /.dl-submenu --> </li> <!-- 博客 --> <li> <a href="#">博客</a> <ul class="dl-submenu"> <li><a href="/posts/">博客</a></li> <li><a href="/tags/">标签</a></li> </ul> </li> <!-- 随笔 --> <li> <a href="/notes/" rel="noopener noreferrer">随笔</a> </li> <!-- 项目 --> <li> <a href="/projects/" rel="noopener noreferrer">项目</a> </li> </ul>
<!-- /.dl-menu --> </nav><!-- /.dl-menuwrapper --> <!-- Header --> <header class="header" role="banner"> <div class="wrapper animated fadeIn"> <div class="content"> <div class="post-title "> <h1>面向切面编程（AOP）</h1> <h4>26 Oct 2015</h4> <p class="reading-time"> <i class="fa fa-clock-o"></i> Reading time ~2 minutes </p>
<!-- /.entry-reading-time --> <a class="btn zoombtn" href="/posts/"> <i class="fa fa-chevron-left"></i> </a> </div> <h1 id="id-aop">AOP（面向切面编程）</h1> <p>在软件行业中，AOP为Aspect Oriented programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续。利用AOP可以对业务逻辑的各各部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p> <p>ps: 可以先看一下NSObject的<code class="highlighter-rouge">load</code>方法</p> <h2 id="id-method-swizzling">Method Swizzling</h2> <p>ps: <a href="http://tech.glowing.com/cn/method-swizzling-aop/">Method Swizzling 和 AOP 实践</a></p> <p>Method Swizzling利用Objective-C Runtime的特性把一个方法的实现与另一个方法的实现进行替换，进而实现AOP。</p> <p>首先定义一个类别，添加将要Swizzled的方法：</p> <div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">@implementation</span> <span class="nc">UIViewController</span> <span class="p">(</span><span class="nl">AOP</span><span class="p">)</span>

<span class="err">-</span> <span class="err">(</span><span class="nc">void</span><span class="p">)</span><span class="n">swizzled_viewWillAppear</span><span class="o">:</span><span class="p">(</span><span class="n">BOOL</span><span class="p">)</span><span class="n">animated</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"Before viewWillAppear"</span><span class="p">);</span>
    <span class="p">[</span><span class="n">self</span> <span class="nf">swizzled_viewWillAppear</span><span class="p">:</span><span class="n">animated</span><span class="p">];</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"After viewWillAppear"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div> <p>代码看起来可能有点奇怪，像递归不是么。当然不会是递归，因为在 runtime 的时候，函数实现已经被交换了。调用<code class="highlighter-rouge">viewWillAppear:</code>会调用你实现的 <code class="highlighter-rouge">swizzled_viewWillAppear:</code>，而在<code class="highlighter-rouge">swizzled_viewWillAppear:</code>里调用 <code class="highlighter-rouge">swizzled_viewDidAppear:</code>实际上调用的是原来的<code class="highlighter-rouge">viewWillAppear:</code>。</p> <p>接下来实现 swizzle 的方法：</p> <div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">swizzleMethod</span><span class="p">(</span><span class="n">Class</span> <span class="n">class</span><span class="p">,</span> <span class="n">SEL</span> <span class="n">originalSelector</span><span class="p">,</span> <span class="n">SEL</span> <span class="n">swizzledSelector</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// the method might not exist in the class, but in its superclass
</span>    <span class="n">Method</span> <span class="n">originalMethod</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="n">class</span><span class="p">,</span> <span class="n">originalSelector</span><span class="p">);</span>
    <span class="n">Method</span> <span class="n">swizzledMethod</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="n">class</span><span class="p">,</span> <span class="n">swizzledSelector</span><span class="p">);</span>

    <span class="c1">// class_addMethod will fail if original method already exists
</span>    <span class="n">BOOL</span> <span class="n">didAddMethod</span> <span class="o">=</span> <span class="n">class_addMethod</span><span class="p">(</span><span class="n">class</span><span class="p">,</span> <span class="n">originalSelector</span><span class="p">,</span> <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">swizzledMethod</span><span class="p">),</span> <span class="n">method_getTypeEncoding</span><span class="p">(</span><span class="n">swizzledMethod</span><span class="p">));</span>

    <span class="c1">// the method doesn’t exist and we just added one
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">didAddMethod</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">class_replaceMethod</span><span class="p">(</span><span class="n">class</span><span class="p">,</span> <span class="n">swizzledSelector</span><span class="p">,</span> <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">originalMethod</span><span class="p">),</span> <span class="n">method_getTypeEncoding</span><span class="p">(</span><span class="n">originalMethod</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">method_exchangeImplementations</span><span class="p">(</span><span class="n">originalMethod</span><span class="p">,</span> <span class="n">swizzledMethod</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div> <p>这里唯一可能需要解释的是<code class="highlighter-rouge">class_addMethod</code>。要先尝试添加原 selector 是为了做一层保护，因为如果这个类没有实现<code class="highlighter-rouge">originalSelector</code>，但其父类实现了，那<code class="highlighter-rouge">class_getInstanceMethod</code>会返回父类的方法。这样<code class="highlighter-rouge">method_exchangeImplementations</code>替换的是父类的那个方法，这当然不是你想要的。所以我们先尝试添加<code class="highlighter-rouge">orginalSelector</code>，如果已经存在，再用<code class="highlighter-rouge">method_exchangeImplementations</code>把原方法的实现跟新的方法实现给交换掉。</p> <p>最后，我们只需要确保在程序启动的时候调用 swizzleMethod 方法。比如，我们可以在之前UIViewController 的 AOP 类别里添加 +load: 方法，然后在 +load: 里把<code class="highlighter-rouge">viewWillAppear</code>给替换掉：</p> <div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">@implementation</span> <span class="nc">UIViewController</span> <span class="p">(</span><span class="nl">AOP</span><span class="p">)</span>

<span class="err">+</span> <span class="err">(</span><span class="nc">void</span><span class="p">)</span><span class="n">load</span>
<span class="p">{</span>
    <span class="n">swizzleMethod</span><span class="p">([</span><span class="n">self</span> <span class="nf">class</span><span class="p">],</span> <span class="k">@selector</span><span class="p">(</span><span class="n">viewWillAppear</span><span class="o">:</span><span class="p">),</span> <span class="k">@selector</span><span class="p">(</span><span class="n">swizzled_viewWillAppear</span><span class="o">:</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div> <p>一般情况下，类别里的方法会重写掉主类里相同命名的方法。如果有两个类别实现了相同命名的方法，只有一个方法会被调用。但 +load: 是个特例，当一个类被读到内存的时候， runtime 会给这个类及它的每一个类别都发送一个 +load: 消息。</p> <p>其实，这里还可以更简化点：直接用新的 IMP 取代原 IMP ，而不是替换。只需要有全局的函数指针指向原 IMP 就可以。</p> <div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="p">(</span><span class="n">gOriginalViewDidAppear</span><span class="p">)(</span><span class="n">id</span><span class="p">,</span> <span class="n">SEL</span><span class="p">,</span> <span class="n">BOOL</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">newViewDidAppear</span><span class="p">(</span><span class="n">UIViewController</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">SEL</span> <span class="n">_cmd</span><span class="p">,</span> <span class="n">BOOL</span> <span class="n">animated</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"Before viewWillAppear"</span><span class="p">);</span>
    <span class="c1">// call original implementation
</span>    <span class="n">gOriginalViewDidAppear</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">_cmd</span><span class="p">,</span> <span class="n">animated</span><span class="p">);</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"After viewWillAppear"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">load</span>
<span class="p">{</span>
    <span class="n">Method</span> <span class="n">originalMethod</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="k">@selector</span><span class="p">(</span><span class="n">viewDidAppear</span><span class="o">:</span><span class="p">));</span>
    <span class="n">gOriginalViewDidAppear</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">method_getImplementation</span><span class="p">(</span><span class="n">originalMethod</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">class_addMethod</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="k">@selector</span><span class="p">(</span><span class="n">viewDidAppear</span><span class="o">:</span><span class="p">),</span> <span class="p">(</span><span class="n">IMP</span><span class="p">)</span> <span class="n">newViewDidAppear</span><span class="p">,</span> <span class="n">method_getTypeEncoding</span><span class="p">(</span><span class="n">originalMethod</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">method_setImplementation</span><span class="p">(</span><span class="n">originalMethod</span><span class="p">,</span> <span class="p">(</span><span class="n">IMP</span><span class="p">)</span> <span class="n">newViewDidAppear</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div> <h2 id="id-aspects">Aspects库</h2> <p><a href="https://github.com/steipete/Aspects">Aspects</a>一个简单高效的面向切面编程库。</p> <p>它允许你将代码添加到每个类／每个实例中现有的方法中，同时可以想想插入的时间点，如：方法执行前、方法执行中、方法执行后。<code class="highlighter-rouge">Aspects</code>可以非常好的处理响应，并且要比普通的 method swizzling 更容易使用。</p> <p>它曾经是<a href="http://pspdfkit.com/">PSPDFKIT</a>的一部分，现在单独开源出来给大家使用，<code class="highlighter-rouge">Aspects</code>很稳定并且已经应用于数百个App了。</p> <p><code class="highlighter-rouge">Aspects给</code>NSObject`扩展了如下的方法：</p> <div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="c1">/// 为一个指定的类的某个方法执行前/替换/后,添加一段代码块.对这个类的所有对象都会起作用.
///
/// @param block  方法被添加钩子时,Aspectes会拷贝方法的签名信息.
/// 第一个参数将会是 `id&lt;AspectInfo&gt;`,余下的参数是此被调用的方法的参数.
/// 这些参数是可选的,并将被用于传递给block代码块对应位置的参数.
/// 你甚至使用一个没有任何参数或只有一个`id&lt;AspectInfo&gt;`参数的block代码块.
///
/// @注意 不支持给静态方法添加钩子.
/// @return 返回一个唯一值,用于取消此钩子.
</span><span class="k">+</span> <span class="p">(</span><span class="n">id</span><span class="o">&lt;</span><span class="n">AspectToken</span><span class="o">&gt;</span><span class="p">)</span><span class="nf">aspect_hookSelector</span><span class="p">:(</span><span class="n">SEL</span><span class="p">)</span><span class="nv">selector</span>
                      <span class="nf">withOptions</span><span class="p">:(</span><span class="n">AspectOptions</span><span class="p">)</span><span class="nv">options</span>
                       <span class="nf">usingBlock</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">block</span>
                            <span class="nf">error</span><span class="p">:(</span><span class="n">NSError</span> <span class="o">**</span><span class="p">)</span><span class="nv">error</span><span class="p">;</span>

<span class="c1">/// 为一个指定的对象的某个方法执行前/替换/后,添加一段代码块.只作用于当前对象.
</span> <span class="k">-</span> <span class="p">(</span><span class="n">id</span><span class="o">&lt;</span><span class="n">AspectToken</span><span class="o">&gt;</span><span class="p">)</span><span class="nf">aspect_hookSelector</span><span class="p">:(</span><span class="n">SEL</span><span class="p">)</span><span class="nv">selector</span> <span class="nf">withOptions</span><span class="p">:(</span><span class="n">AspectOptions</span><span class="p">)</span><span class="nv">options</span> <span class="nf">usingBlock</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">block</span> <span class="nf">error</span><span class="p">:(</span><span class="n">NSError</span> <span class="o">**</span><span class="p">)</span><span class="nv">error</span><span class="p">;</span>
<span class="c1">/// 撤销一个Aspect 钩子.
/// @return YES 撤销成功, 否则返回 NO.
</span><span class="n">id</span><span class="o">&lt;</span><span class="n">AspectToken</span><span class="o">&gt;</span> <span class="n">aspect</span> <span class="o">=</span> <span class="p">...;</span>
<span class="p">[</span><span class="n">aspect</span> <span class="nf">remove</span><span class="p">];</span>
</code></pre></div> <p>所有的调用都是线程安全的。Aspectes使用了Objective-C的消息转发机会。这将会有一些额外的消耗。所以对于频繁的调用，不建议使用Aspects库。Aspects更适用于视图／控制器等每秒调用不超过1000次的代码。</p> <h3 id="id-aspects-1">使用Aspects示例</h3> <p>可以在调试时，使用Aspects动态添加日志：</p> <div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">UIViewController</span> <span class="nf">aspect_hookSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nf">viewWillAppear</span><span class="p">:)</span> <span class="nf">withOptions</span><span class="p">:</span><span class="n">AspectPositionAfter</span> <span class="nf">usingBlock</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">id</span><span class="o">&lt;</span><span class="n">AspectInfo</span><span class="o">&gt;</span> <span class="n">aspectInfo</span><span class="p">,</span> <span class="n">BOOL</span> <span class="n">animated</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"View Controller %@ will appear animated: %tu"</span><span class="p">,</span> <span class="n">aspectInfo</span><span class="p">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">animated</span><span class="p">)</span><span class="err">;</span>
<span class="p">}</span> <span class="nf">error</span><span class="p">:</span><span class="nb">NULL</span><span class="p">];</span>
</code></pre></div> <p>可以很简单的设置分析功能：<a href="https://github.com/orta/ARAnalytics">https://github.com/orta/ARAnalytics</a></p> <p>在测试用例中检查方法是否真的被调用(当涉及到继承或类目扩展时,很容易发生某个父类/子类方法未按预期调用的情况)：</p> <div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">testExample</span> <span class="p">{</span>
    <span class="n">TestClass</span> <span class="o">*</span><span class="n">testClass</span> <span class="o">=</span> <span class="p">[</span><span class="n">TestClass</span> <span class="nf">new</span><span class="p">];</span>
    <span class="n">TestClass</span> <span class="o">*</span><span class="n">testClass2</span> <span class="o">=</span> <span class="p">[</span><span class="n">TestClass</span> <span class="nf">new</span><span class="p">];</span>

    <span class="n">__block</span> <span class="n">BOOL</span> <span class="n">testCallCalled</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
    <span class="p">[</span><span class="n">testClass</span> <span class="nf">aspect_hookSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">testCall</span><span class="p">)</span> <span class="nf">withOptions</span><span class="p">:</span><span class="n">AspectPositionAfter</span> <span class="nf">usingBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
        <span class="n">testCallCalled</span> <span class="o">=</span> <span class="nb">YES</span><span class="err">;</span>
    <span class="p">}</span> <span class="nf">error</span><span class="p">:</span><span class="nb">NULL</span><span class="p">];</span>

    <span class="p">[</span><span class="n">testClass2</span> <span class="nf">testCallAndExecuteBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
        <span class="p">[</span><span class="n">testClass</span> <span class="nf">testCall</span><span class="p">]</span><span class="err">;</span>
    <span class="p">}</span> <span class="nf">error</span><span class="p">:</span><span class="nb">NULL</span><span class="p">];</span>
    <span class="n">XCTAssertTrue</span><span class="p">(</span><span class="n">testCallCalled</span><span class="p">,</span> <span class="s">@"Calling testCallAndExecuteBlock must call testCall"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div> <p>它对调试应用真的会提供很大的作用.这里我想要知道究竟何时轻击手势的状态发生变化(如果是某个你自定义的手势的子类,你可以重写setState:方法来达到类似的效果;但这里的真正目的是,捕捉所有的各类控件的轻击手势,以准确分析原因):</p> <div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">_singleTapGesture</span> <span class="nf">aspect_hookSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nf">setState</span><span class="p">:)</span> <span class="nf">withOptions</span><span class="p">:</span><span class="n">AspectPositionAfter</span> <span class="nf">usingBlock</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">id</span><span class="o">&lt;</span><span class="n">AspectInfo</span><span class="o">&gt;</span> <span class="n">aspectInfo</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@: %@"</span><span class="p">,</span> <span class="n">aspectInfo</span><span class="p">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">aspectInfo</span><span class="p">.</span><span class="n">arguments</span><span class="p">)</span><span class="err">;</span>
<span class="p">}</span> <span class="nf">error</span><span class="p">:</span><span class="nb">NULL</span><span class="p">];</span>
</code></pre></div> <p>另一种很方便的用例是可以给类中添加还没有的处理程序。在<code class="highlighter-rouge">PSPDFKit</code>中，当一个视图控制器将要dismiss的时候，我们需要通知它完成写入。包括UIKit的视图控制器如，<code class="highlighter-rouge">MFMailComposeViewController</code>、<code class="highlighter-rouge">UIImagePickerController</code>。我们可以为每一个控制器创建子类，但这将产生许多不必要的代码。<code class="highlighter-rouge">Aspects</code>为词提供一个简单的解决方案：</p> <div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">@implementation</span> <span class="nc">UIViewController</span> <span class="p">(</span><span class="nl">DismissActionHook</span><span class="p">)</span>

<span class="c1">// Will add a dismiss action once the controller gets dismissed.
</span><span class="err">-</span> <span class="err">(</span><span class="nc">void</span><span class="p">)</span><span class="n">pspdf_addWillDismissAction</span><span class="o">:</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span><span class="n">action</span> <span class="p">{</span>
    <span class="n">PSPDFAssert</span><span class="p">(</span><span class="n">action</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="p">[</span><span class="n">self</span> <span class="nf">aspect_hookSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nf">viewWillDisappear</span><span class="p">:)</span> <span class="nf">withOptions</span><span class="p">:</span><span class="n">AspectPositionAfter</span> <span class="nf">usingBlock</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">id</span><span class="o">&lt;</span><span class="n">AspectInfo</span><span class="o">&gt;</span> <span class="n">aspectInfo</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">([</span><span class="n">aspectInfo</span><span class="p">.</span><span class="n">instance</span> <span class="nf">isBeingDismissed</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">action</span><span class="p">()</span><span class="err">;</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="nf">error</span><span class="p">:</span><span class="nb">NULL</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">@end</span>
</code></pre></div> <h3 id="id-section">调试的好处</h3> <p>Aspectes 会自动标记自己,所以很容易在调用栈中查看某个方法是否已经调用:</p> <p><img src="/assets/posts/AOP/aspects_debug.png" alt="图一"></p> <h3 id="id-void-aspects">在返回值不为void的方法上使用 Aspects</h3> <p>你可以使用 NSInvocation 对象类自定义返回值:</p> <div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">PSPDFDrawView</span> <span class="nf">aspect_hookSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nf">shouldProcessTouches</span><span class="p">:</span><span class="nf">withEvent</span><span class="p">:)</span> <span class="nf">withOptions</span><span class="p">:</span><span class="n">AspectPositionInstead</span> <span class="nf">usingBlock</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">id</span><span class="o">&lt;</span><span class="n">AspectInfo</span><span class="o">&gt;</span> <span class="n">info</span><span class="p">,</span> <span class="n">NSSet</span> <span class="o">*</span><span class="n">touches</span><span class="p">,</span> <span class="n">UIEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 调用方法原来的实现.
</span>        <span class="n">BOOL</span> <span class="n">processTouches</span><span class="err">;</span>
        <span class="n">NSInvocation</span> <span class="o">*</span><span class="n">invocation</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">originalInvocation</span><span class="err">;</span>
        <span class="p">[</span><span class="n">invocation</span> <span class="nf">invoke</span><span class="p">]</span><span class="err">;</span>
        <span class="p">[</span><span class="n">invocation</span> <span class="nf">getReturnValue</span><span class="p">:</span><span class="o">&amp;</span><span class="n">processTouches</span><span class="p">]</span><span class="err">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">processTouches</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">processTouches</span> <span class="o">=</span> <span class="n">pspdf_stylusShouldProcessTouches</span><span class="p">(</span><span class="n">touches</span><span class="p">,</span> <span class="n">event</span><span class="p">)</span><span class="err">;</span>
            <span class="p">[</span><span class="n">invocation</span> <span class="nf">setReturnValue</span><span class="p">:</span><span class="o">&amp;</span><span class="n">processTouches</span><span class="p">]</span><span class="err">;</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="nf">error</span><span class="p">:</span><span class="nb">NULL</span><span class="p">];</span>
</code></pre></div> <h3 id="id-section-1">兼容性与限制</h3> <ul> <li>当应用于某个类时(使用类方法添加钩子),不能同时hook父类和子类的同一个方法;否则会引起循环调用问题.但是,当应用于某个类的示例时(使用实例方法添加钩子),不受此限制.</li> <li>使用KVO时,最好在 aspect_hookSelector: 调用之后添加观察者;否则可能会引起崩溃.</li> </ul> <h3 id="id-section-2">最后</h3> <p>Method Swizzling以及Runtime的一些特性就是iOS里的黑科技，如果能灵活应用的话可以在保证解决问题的前提下降低模块之间的耦合度，提高代码的可复用性。至于Method Swizzling与Aspect库的选择因人而异，我个人建议在最初阶段先放下Aspect而只用Method Swizzling原始代码去实现代码注入。掌握本质总是不吃亏的。</p> <h2 id="id-nsproxy">NSProxy</h2> <p><a href="http://blog.csdn.net/yanghua_kobe/article/details/8395535">NSProxy实现AOP方便为ios应用实现异常处理策略</a></p> <div class="entry-meta"> <br> <hr> <span class="entry-tags"><a href="/tags/#iOS" title="Pages tagged iOS" class="tag"><span class="term">iOS</span></a><a href="/tags/#AOP" title="Pages tagged AOP" class="tag"><span class="term">AOP</span></a></span> <span class="social-share"> <a href="https://www.facebook.com/sharer/sharer.php?u=/posts/2015/10/26/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B(AOP)/" title="Share on Facebook" class="tag"> <span class="term"><i class="fa fa-facebook-square"></i> Like</span> </a> <a href="https://twitter.com/intent/tweet?text=/posts/2015/10/26/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B(AOP)/" title="Share on Twitter" class="tag"> <span class="term"><i class="fa fa-twitter-square"></i> Tweet</span> </a> <a href="https://plus.google.com/share?url=/posts/2015/10/26/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B(AOP)/" title="Share on Google+" class="tag"> <span class="term"><i class="fa fa-google-plus-square"></i> +1</span> </a> </span> <div style="clear:both"></div> </div> </div> </div> <!-- /#commentit_thread 评论UI --> <section id="commentit_thread" class="animated fadeInUp"></section> </header> <!-- JS --> <script src="/assets/js/jquery-1.12.0.min.js"></script> <script src="/assets/js/jquery.dlmenu.min.js"></script> <script src="/assets/js/jquery.goup.min.js"></script> <script src="/assets/js/jquery.magnific-popup.min.js"></script> <script src="/assets/js/jquery.fitvid.min.js"></script> <script src="/assets/js/scripts.js"></script> <!-- Asynchronous Google Analytics snippet --> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-83690324-2', 'auto'); ga('require', 'linkid', 'linkid.js'); ga('send', 'pageview'); </script> <!-- Comm(ent|it)评论加载 https://commentit.io/ --> <!-- 历史评论列表 --> <!-- There are no comments on this post. --> <!-- 发表评论 --> <noscript>Please enable JavaScript to view the comment form powered by <a href="https://commentit.io/">Comm(ent|it)</a>
</noscript> <div id="commentit"></div> <script type="text/javascript"> /** CONFIGURATION VARIABLES **/ var commentitUsername = 'myzerone'; var commentitRepo = 'myzerone/myzerone.github.io'; var commentitId = '/posts/2015/10/26/面向切面编程(AOP)'; /** DON'T EDIT FOLLOWING LINES **/ (function() { if (!document.getElementById('commentit_thread')) { return; }　 var commentit = document.createElement('script'); commentit.type = 'text/javascript'; commentit.async = true; commentit.src = 'https://commentit.io/static/embed/dist/commentit.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(commentit); document.getElementById('commentit_thread').appendChild(document.getElementById('commentit')); })(); </script> </body> </html>
